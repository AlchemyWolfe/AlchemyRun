High Level Design:

AlchemyRecipeComponent - contains info and procedures necessary for generation.
	Can I have a field that is data for a procedural generation routine and another field that is the class that will take that data and generate Actors?
	I like the idea that each Actor will remember a list of Actors generated by it, so they can all be cleaned up on regeneration.
	When GenerateReagents is called on it, it creates two lists:
		Actors that do not contain AlchemyRecipeComponent, just to be deleted on regeneration.
		Actors that do have an AlchemyRecipeComponent, which will be used by Alchemist in the breadth first generation, and possibly in the future for delayed generation.
	A boolean marking if actors have been generated for this recipe.

AlchemyCollection - contains relates assets that could be swapped out for each other, such as all the Actors that are shrubbery. 
	Optimize for speed of getting a random element.

AlchemyCatalog - contains related assets, such as walls & floors to make rooms and hallways with.  Some of these may be AlchemyCollections.
	Optimize for speed of lookup by tags.  Maybe actually preparse into lists defined by tag?

Alchemist - The thing that is put in a level that will generate Actors on level load, when palced in a level, or when the designer causes it to refresh
	Breadth first generation: The generation routine completes the top level recipe, keeping a list of any Actors that have AlchemyRecipeComponent that have non zero lists of children that have recipies.
	Slow generation: I want the level to essentially animate into existence.  It would be nice if there was a 0.5 second animation that played of the Actor growing from 1% to 110% scale, then back to 100% scale, and that there was a 0.005 second delay in the generation of each Actor.

AlchemyAssetManager : public UAssetManager - Not necessary yet, but by the time the game is published, I want to be able to only load Actors that I wish to use.  Perhaps Catalogs anbd Collections all load in the beginning, but actual Actors (or meshes and textures?) will only load when generated.

AlchemyRecipeComponent Interaction:  There will be some need to get AlchemyCatalog information from parent recipies.  For example, there could be different walls, floors, lighting, etc. for dungeons based on different themes: blue, ice, lava, wood, marble, etc.  The recipe for the Dungeon will have the AlchemyCatalog for the theme, and pass it to every room recipe.  It will never communicate with adjacent recipies.  No room will reference another room.

Circular dependencies should be designer prevented.  There is a conceptual hierarchy of recipies.  For example, a dungeon will never make another dungeon, nor will a room make a dungeon.  I do not think we need code for this.

Partial Regeneration: This is why AlchemyRecipeComponent contains the list of all Actors that were generated for that recipe.  While Alchemist will be the one calling GenerateReagents, Alchemist will be able to regenerate everything from a specific AlchemyRecipeComponent down without altering any other recipe.

Higher Level Modification: A recipe may need to be reinitialized several times before actual generation.  For example, in creating a roguelike dungeon, rooms are placed and then hallways are added.  This will cause a given room to have doors added many times before actually generating that room should happen.  This should be part of the code of the roguelike dungeon recipe.

Animation: The Alchemist should be where the animations live.  In the future, we may add an animation tag to AlchemyRecipeComponent to select which animation play from the ones Alchemist has.  For now, one animation is fine.

Batch Generation: Perhaps a recipe can tell Alchemist to generate and animate a list of reagents all at once.  This would also allow some reagents to not need animation, such as spawn points.

AlchemyAssetManager: We can leave streaming mostly stubbed and commented for later.  The game is not yet big enough for that to be an issue.

Gameplay Feedback: Add hooks so parts of a recipe can be generated later.  A great example of this would be only spawning enemies when the player enters a room.

Blueprints vs. Code: Initially, Designers will only be able to influence the procedural generation routine via data they provide to the recipe, and gameplay feedback hooks.  However, AlchemyRecipeComponent is essentually only a base class.  Classes derived from it may include more Blueprints functionality.

Runtime generation will need to be deterministic.  Each AlchemyRecipeComponent should have it's own FRandomStream initialized by the seed passed in from the recipe that created it.  The first recipe that Alchemist creates will get the seed from some player data to be determined later.

Additional classes:

AlchemyRecipeComponentRoguelikeDungeon - This will create a bunch of randomly placed and sized rooms and add hallways between them.
AlchemyRecipeComponentDungeonRoom - This will have data set by the parent recipe, including: which reagents to use for walls and floor, a fill box which is the maximum size of the room, and where hallways connect to the room and thus need doors.
AlchemyRecipeComponentDungeonHalway - This will take a path and build a hallway along the path, not creating doors.
AlchemyRecipeComponentDungeonDeadEnd - This will create a small space with no exits and no doors, used to cap hallways that do not connect to rooms.

Before generating any code, does this answer enough questions that you could begin writing the code?


